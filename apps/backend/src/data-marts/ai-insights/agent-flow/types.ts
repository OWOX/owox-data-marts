import { z } from 'zod';
import { AiContext, AgentTelemetry } from '../../../common/ai-insights/agent/types';
import {
  AiFlowOptions,
  AssistantChatMessage,
  AssistantOrchestratorRequest,
  AssistantOrchestratorResponse,
  AssistantProposedAction,
  AssistantProposedActionSchema,
} from './ai-assistant-types';
import {
  TemplateEditPlaceholderTag,
  TemplateEditPlaceholderTagSchema,
} from '../../services/template-edit-placeholder-tags/template-edit-placeholder-tags.contracts';

export interface AgentFlowRequest {
  projectId: string;
  dataMartId: string;
  history: AssistantChatMessage[];
  sessionContext: {
    sessionId: AssistantOrchestratorRequest['sessionContext']['sessionId'];
    scope: AssistantOrchestratorRequest['sessionContext']['scope'];
    templateId: AssistantOrchestratorRequest['sessionContext']['templateId'];
  };
  options?: AiFlowOptions;
}

/**
 * Context passed to every tool during the agent loop.
 * Extends the base AiContext (which only requires telemetry) with
 * agent-flow-specific data that tools need.
 */
export interface AgentFlowContext extends AiContext {
  telemetry?: AgentTelemetry;
  request: AgentFlowRequest;
  /**
   * Proposed actions accumulated by tools during the agent loop.
   * Tools push into this array; the service reads it after the loop finishes.
   */
  collectedProposedActions: AssistantProposedAction[];
  /**
   * SQL generated by the generate-sql tool during this loop.
   * Set by GenerateSqlTool; read by AgentFlowService to populate response.result.sqlCandidate.
   */
  lastGeneratedSql?: string;
  /** Dry-run validity of the last generated SQL. */
  lastDryRunValid?: boolean;
  /** Internal SQL pipeline reason text from source orchestrator response meta. */
  lastGeneratedSqlReasonDescription?: string;
  /** Internal SQL pipeline diagnostics from source orchestrator response meta. */
  lastGeneratedSqlDiagnostics?: AssistantOrchestratorResponse['meta']['diagnostics'];
  /** Sanitized user message used after policy recovery (if any). */
  sanitizedLastUserMessage?: string | null;
}

export const AgentFlowConversationSnapshotContentSchema = z.object({
  goal: z.string().nullable(),
  decisions: z.array(z.string()),
  appliedChanges: z.array(z.string()),
  openQuestions: z.array(z.string()),
  importantFacts: z.array(z.string()),
  lastUserIntent: z.string().nullable(),
});

export type AgentFlowConversationSnapshotContent = z.infer<
  typeof AgentFlowConversationSnapshotContentSchema
>;

export const AgentFlowConversationSnapshotSchema =
  AgentFlowConversationSnapshotContentSchema.extend({
    compressedTurns: z.number().int().nonnegative(),
    updatedAt: z.string().min(1),
  });

export type AgentFlowConversationSnapshot = z.infer<typeof AgentFlowConversationSnapshotSchema>;

export interface AgentFlowStateSnapshotSource {
  sourceKey: string;
  artifactId: string | null;
  artifactTitle: string | null;
  isAttachedToTemplate: boolean;
  sqlHash: string | null;
  sqlPreview: string | null;
  updatedAt: string | null;
}

export interface AgentFlowStateSnapshotActionDigest {
  requestId: string;
  assistantMessageId: string | null;
  lifecycleStatus: 'created' | 'applied' | null;
  modifiedAt: string;
}

export interface AgentFlowStateSnapshotSqlRevision {
  sqlRevisionId: string;
  sqlPreview: string;
  createdAt: string;
}

export interface AgentFlowStateSnapshot {
  sessionId: string;
  templateId: string | null;
  sources: AgentFlowStateSnapshotSource[];
  appliedActions: AgentFlowStateSnapshotActionDigest[];
  pendingActions: AgentFlowStateSnapshotActionDigest[];
  sqlRevisions: AgentFlowStateSnapshotSqlRevision[];
}

export interface AgentFlowPromptContext {
  recentTurns: AssistantChatMessage[];
  conversationSnapshot: AgentFlowConversationSnapshot | null;
  stateSnapshot: AgentFlowStateSnapshot;
}

export const AgentFlowDecisionSchema = z.enum([
  // For all decisions, the agent must provide a user-facing explanation.
  'explain',
  // Propose a specific action to the user, with optional structured proposedActions for UI.
  'propose_action',
  // Ask the user a clarifying question to get more information before deciding on an action.
  'clarify',
  // Decide to edit the template.
  'edit_template',
]);
export type AgentFlowDecision = z.infer<typeof AgentFlowDecisionSchema>;

const AgentFlowProposedActionSchema = z.discriminatedUnion(
  'type',
  AssistantProposedActionSchema.options as unknown as [
    (typeof AssistantProposedActionSchema.options)[number],
    ...(typeof AssistantProposedActionSchema.options)[number][],
  ]
);

export const AgentFlowTemplateEditTagSchema = TemplateEditPlaceholderTagSchema;
export type AgentFlowTemplateEditTag = TemplateEditPlaceholderTag;

export const AgentFlowTemplateEditIntentSchema = z
  .object({
    type: z
      .literal('replace_template_document')
      .describe('Only supported template editing intent type in AgentFlow.'),
    text: z
      .string()
      .min(1)
      .describe(
        'Template text (markdown or plain text) with placeholders like [[TAG:t1]]. ' +
          'Do NOT include raw template tags {{...}} here.'
      ),
    tags: z
      .array(AgentFlowTemplateEditTagSchema)
      .describe(
        'Typed tag definitions referenced by placeholders in text. ' +
          'Each text placeholder [[TAG:id]] must match a tag item with the same id.'
      ),
  })
  .strict();
export type AgentFlowTemplateEditIntent = z.infer<typeof AgentFlowTemplateEditIntentSchema>;

export const AgentFlowResultSchema = z
  .object({
    decision: AgentFlowDecisionSchema.describe(
      'Final decision on how to respond to the user message.'
    ),
    explanation: z
      .string()
      .min(1)
      .describe(
        'User-facing explanation or response text. ' +
          'For "propose_action" — describe what is being proposed. ' +
          'For "clarify" — ask the clarifying question. ' +
          'For "explain" — answer the user. ' +
          'For "edit_template" — describe what was changed.'
      ),
    reasonDescription: z
      .string()
      .min(1)
      .describe(
        'Internal concise reason for logs/telemetry. ' +
          'Not a user-facing message. ' +
          'Must explain why this decision was chosen.(1-2 sentences)'
      ),
    proposedActions: z
      .array(AgentFlowProposedActionSchema)
      .optional()
      .describe(
        'Optional explicit actions to propose to the user. ' +
          'Use this for decision="propose_action". '
      ),
    templateEditIntent: AgentFlowTemplateEditIntentSchema.optional().describe(
      'Template edit payload for decision="edit_template". ' +
        'Use placeholders in text ([[TAG:id]]) and provide actual tag definitions in tags[].'
    ),
  })
  .strict();
export type AgentFlowResult = z.infer<typeof AgentFlowResultSchema>;
